<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.23">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Aryan Pagdaloo">

<title>Decision Tree Challenge</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-1fe81d0376b2c50856e68e651e390326.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="index.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Decision Tree Challenge</h1>
<p class="subtitle lead">Feature Importance and Categorical Variable Encoding</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Aryan Pagdaloo </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="decision-tree-challenge---feature-importance-and-variable-encoding" class="level1">
<h1>üå≥ Decision Tree Challenge - Feature Importance and Variable Encoding</h1>
<section id="overview" class="level2">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<p>This analysis explores how decision trees measure feature importance and examines the critical differences between categorical and numerical variable encoding. We‚Äôll discover why treating categorical variables (like zip codes) as numbers can completely distort our understanding of what actually drives predictions.</p>
<p><strong>Jump to:</strong> <a href="#sec-discussion">Analysis &amp; Discussion</a></p>
</section>
<section id="the-decision-tree-problem" class="level2">
<h2 class="anchored" data-anchor-id="the-decision-tree-problem">The Decision Tree Problem üéØ</h2>
<blockquote class="blockquote">
<p>‚ÄúThe most important thing in communication is hearing what isn‚Äôt said.‚Äù - Peter Drucker</p>
</blockquote>
<p><strong>The Core Problem:</strong> Decision trees are often praised for their interpretability and ability to handle both numerical and categorical variables. But what happens when we encode categorical variables as numbers? How does this affect our understanding of feature importance?</p>
<p><strong>What is Feature Importance?</strong> In decision trees, feature importance measures how much each variable contributes to reducing impurity (or improving prediction accuracy) across all splits in the tree. It‚Äôs a key metric for understanding which variables matter most for your predictions.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Important
</div>
</div>
<div class="callout-body-container callout-body">
<p>üéØ The Key Insight: Encoding Matters for Interpretability</p>
<p><strong>The problem:</strong> When we encode categorical variables as numerical values (like 1, 2, 3, 4‚Ä¶), decision trees treat them as if they have a meaningful numerical order. This can completely distort our analysis.</p>
<p><strong>The Real-World Context:</strong> In real estate, we know that neighborhood quality, house style, and other categorical factors are crucial for predicting home prices. But if we encode these as numbers, we might get misleading insights about which features actually matter most.</p>
<p><strong>The Devastating Reality:</strong> Even sophisticated machine learning models can give us completely wrong insights about feature importance if we don‚Äôt properly encode our variables. A categorical variable that should be among the most important might appear irrelevant, while a numerical variable might appear artificially important.</p>
</div>
</div>
<p>Let‚Äôs assume we want to predict house prices and understand which features matter most. The key question is: <strong>How does encoding categorical variables as numbers affect our understanding of feature importance?</strong></p>
<p>Following our analysis, we‚Äôll investigate these critical questions in our <a href="#sec-discussion">Discussion Questions</a> section, where we examine both the theoretical and practical implications of these encoding choices.</p>
</section>
<section id="the-ames-housing-dataset" class="level2">
<h2 class="anchored" data-anchor-id="the-ames-housing-dataset">The Ames Housing Dataset üè†</h2>
<p>We are analyzing the Ames Housing dataset which contains detailed information about residential properties sold in Ames, Iowa from 2006 to 2010. This dataset is perfect for our analysis because it contains a categorical variable (like zip code) and numerical variables (like square footage, year built, number of bedrooms).</p>
</section>
<section id="the-problem-zipcode-as-numerical-vs-categorical" class="level2">
<h2 class="anchored" data-anchor-id="the-problem-zipcode-as-numerical-vs-categorical">The Problem: ZipCode as Numerical vs Categorical</h2>
<p><strong>Key Question:</strong> What happens when we treat zipCode as a numerical variable in a decision tree? How does this affect feature importance interpretation?</p>
<p><strong>The Issue:</strong> Zip codes (50010, 50011, 50012, 50013) are categorical variables representing discrete geographic areas, i.e.&nbsp;neighborhoods. When treated as numerical, the tree might split on ‚ÄúzipCode &gt; 50012.5‚Äù - which has no meaningful interpretation for house prices. Zip codes are non-ordinal categorical variables meaning they have no inherent order that aids house price prediction (i.e.&nbsp;zip code 99999 is not the priceiest zip code).</p>
</section>
<section id="data-loading-and-model-building" class="level2">
<h2 class="anchored" data-anchor-id="data-loading-and-model-building">Data Loading and Model Building</h2>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Model built with 7 terminal nodes</code></pre>
</div>
</div>
</section>
<section id="tree-visualization" class="level2">
<h2 class="anchored" data-anchor-id="tree-visualization">Tree Visualization</h2>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/visualize-tree-r-1.png" class="img-fluid figure-img" width="960"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="feature-importance-analysis" class="level2">
<h2 class="anchored" data-anchor-id="feature-importance-analysis">Feature Importance Analysis</h2>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/importance-plot-r-1.png" class="img-fluid figure-img" width="768"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="critical-analysis-the-encoding-problem" class="level2">
<h2 class="anchored" data-anchor-id="critical-analysis-the-encoding-problem">Critical Analysis: The Encoding Problem</h2>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Warning</span>‚ö†Ô∏è The Problem Revealed
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>What to note:</strong> Our decision tree treated <code>zipCode</code> as a numerical variable. This leads to zip code being unimportant. Not surprisingly, because there is no reason to believe allowing splits like ‚ÄúzipCode &lt; 50012.5‚Äù should be beneficial for house price prediction. This false coding of a variable creates several problems:</p>
<ol type="1">
<li><strong>Potentially Meaningless Splits:</strong> A zip code of 50013 is not ‚Äúgreater than‚Äù 50012 in any meaningful way for house prices</li>
<li><strong>False Importance:</strong> The algorithm assigns importance to zipCode based on numerical splits rather than categorical distinctions OR the importance of zip code is completely missed as numerical ordering has no inherent relationship to house prices.</li>
<li><strong>Misleading Interpretations:</strong> We might conclude zipCode is not important when our intuition tells us it should be important (listen to your intuition).</li>
</ol>
<p><strong>The Real Issue:</strong> Zip codes are categorical variables representing discrete geographic areas. The numerical values have no inherent order or magnitude relationship to house prices. These must be modelled as categorical variables.</p>
</div>
</div>
</section>
<section id="proper-categorical-encoding-the-solution" class="level2">
<h2 class="anchored" data-anchor-id="proper-categorical-encoding-the-solution">Proper Categorical Encoding: The Solution</h2>
<p>Now let‚Äôs repeat the analysis with zipCode properly encoded as a categorical variable to see the difference. We‚Äôll convert zipCode to a factor (categorical variable) in R.</p>
</section>
<section id="categorical-encoding-analysis" class="level2">
<h2 class="anchored" data-anchor-id="categorical-encoding-analysis">Categorical Encoding Analysis</h2>
</section>
<section id="tree-visualization-categorical-zipcode" class="level2">
<h2 class="anchored" data-anchor-id="tree-visualization-categorical-zipcode">Tree Visualization: Categorical zipCode</h2>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/visualize-tree-cat-r-1.png" class="img-fluid figure-img" width="960"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="feature-importance-categorical-zipcode" class="level2">
<h2 class="anchored" data-anchor-id="feature-importance-categorical-zipcode">Feature Importance: Categorical zipCode</h2>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/importance-plot-cat-r-1.png" class="img-fluid figure-img" width="768"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="sec-discussion" class="level2">
<h2 class="anchored" data-anchor-id="sec-discussion">Analysis &amp; Discussion</h2>
<section id="how-should-zip-codes-be-modeled" class="level3">
<h3 class="anchored" data-anchor-id="how-should-zip-codes-be-modeled">1. How Should Zip Codes Be Modeled?</h3>
<p>Looking at our four models‚Äîtwo in R and two in Python‚Äîeach language demonstrates different approaches to handling zip codes as either numerical or categorical variables. Given what we know about zip codes and real estate prices, the question becomes: which approach makes more sense?</p>
<p><strong>Answer:</strong></p>
<p>Zip codes should definitely be modeled as categorical variables when predicting real estate prices. This comes down to understanding what zip codes actually represent: distinct geographic areas with unique characteristics that have no inherent numerical ordering.</p>
<p>When we treat zip codes numerically (as seen in our first models), we create several critical problems:</p>
<p><strong>The False Ordering Problem:</strong> Numerical encoding implies that zip code 50013 is somehow ‚Äúgreater than‚Äù 50012, which has no meaningful relationship to house prices. A decision tree splitting on ‚ÄúzipCode &gt; 50012.5‚Äù assumes properties in zip code 50013 are systematically different from those in 50010, 50011, and 50012 simply because of numerical order‚Äîthis is completely arbitrary.</p>
<p><strong>Loss of Geographic Intelligence:</strong> Each zip code represents a unique neighborhood with distinct characteristics like school districts, proximity to amenities, local economic conditions, and neighborhood prestige. These factors don‚Äôt follow numerical ordering. The most expensive zip code in a city might have a numerically smaller code than the least expensive.</p>
<p><strong>Real-World Reality Check:</strong> Our analysis proves this point perfectly. When zip codes were treated numerically, they barely registered in our feature importance rankings‚Äîwhich completely contradicts what anyone in real estate will tell you about location being everything. But once we properly encoded them as categorical variables, zip codes suddenly became significant predictors, which actually makes sense.</p>
<p><strong>The Categorical Advantage:</strong> Categorical encoding allows the decision tree to learn the true relationship between each specific zip code and house prices. Instead of meaningless splits like ‚ÄúzipCode &gt; 50012.5,‚Äù the tree can make intelligent decisions like ‚Äúif zipCode = 50014, then split left‚Äù versus ‚Äúif zipCode ‚àà {50010, 50011, 50012}, then split right.‚Äù</p>
<p>In essence, treating zip codes numerically forces our model to ignore geographical reality in favor of arbitrary numerical relationships. The categorical approach respects the true nature of location-based data and produces more interpretable, actionable insights for real estate analysis.</p>
</section>
<section id="r-vs-python-why-such-different-results" class="level3">
<h3 class="anchored" data-anchor-id="r-vs-python-why-such-different-results">2. R vs Python: Why Such Different Results?</h3>
<p>When we model zip codes as categorical variables, the results between R and Python differ dramatically. The trees look different, the feature importance rankings change significantly, and the overall model behavior shifts. What‚Äôs causing this divergence, and which approach is actually better for handling categorical data?</p>
<p><strong>Answer:</strong></p>
<p>The dramatic differences between R‚Äôs <code>rpart</code> and Python‚Äôs <code>sklearn.tree.DecisionTreeRegressor</code> when handling categorical variables come down to completely different philosophies about how to deal with categorical data.</p>
<p><strong>R‚Äôs Native Categorical Approach:</strong></p>
<p>R‚Äôs <code>rpart</code> package treats categorical variables (factors) as first-class citizens. When <code>rpart</code> encounters a categorical variable like our zip code factor, it considers all possible binary splits of the categories. For a variable with k categories, this means examining 2^(k-1) - 1 possible splits, allowing the algorithm to find optimal groupings of zip codes based on their actual relationship to house prices.</p>
<p>This approach respects the categorical nature of the data‚Äî<code>rpart</code> doesn‚Äôt impose any artificial ordering or numerical relationships. Instead, it discovers which combinations of zip codes naturally group together in terms of their impact on house prices.</p>
<p><strong>Python‚Äôs Preprocessing Requirement:</strong></p>
<p>Python‚Äôs <code>sklearn.tree.DecisionTreeRegressor</code> takes a fundamentally different approach. The official scikit-learn documentation clearly states: <em>‚ÄúAble to handle both numerical and categorical data. However, the scikit-learn implementation does not support categorical variables for now.‚Äù</em> Additionally, it specifies that DecisionTreeClassifier and DecisionTreeRegressor take <em>‚Äúan array X, sparse or dense, of shape (n_samples, n_features) holding the training samples‚Äù</em> - forcing categorical variables through preprocessing steps like one-hot encoding.</p>
<p>Our Python implementation converted zip codes into multiple binary features (zipCode_50010, zipCode_50011, etc.). While this makes the data numerically compatible, it fundamentally changes how the algorithm perceives and processes the categorical information. Each one-hot encoded feature is treated as an independent binary variable, losing the inherent relationship between the categories.</p>
<p><strong>Why These Differences Matter:</strong></p>
<p>The preprocessing requirement in Python creates several issues:</p>
<ol type="1">
<li><p><strong>Feature Fragmentation:</strong> A single categorical variable becomes multiple binary features, diluting its collective importance across many individual features.</p></li>
<li><p><strong>Split Complexity:</strong> The tree must make multiple binary decisions across different one-hot features to achieve what <code>rpart</code> can accomplish in a single categorical split.</p></li>
<li><p><strong>Computational Overhead:</strong> One-hot encoding dramatically increases the feature space, especially problematic for high-cardinality categorical variables.</p></li>
</ol>
<p><strong>Which Implementation Performs Better?</strong></p>
<p>R‚Äôs <code>rpart</code> provides superior handling of categorical variables for several reasons:</p>
<p><strong>Theoretical Advantage:</strong> <code>rpart</code>‚Äôs ability to consider all possible categorical splits aligns better with the mathematical theory of decision trees for categorical data. It can discover optimal category groupings that one-hot encoding might miss.</p>
<p><strong>Practical Efficiency:</strong> <code>rpart</code> avoids the curse of dimensionality that plagues one-hot encoded approaches when dealing with many categories.</p>
<p><strong>Interpretability:</strong> <code>rpart</code>‚Äôs categorical splits (like ‚ÄúzipCode ‚àà {50010, 50011}‚Äù) are more interpretable than scattered binary decisions across multiple one-hot features.</p>
<p><strong>Documentation Evidence:</strong></p>
<p>The sklearn documentation explicitly acknowledges this limitation. The documentation clearly states: <em>‚Äúscikit-learn uses an optimized version of the CART algorithm; however, the scikit-learn implementation does not support categorical variables for now.‚Äù</em> This fundamental limitation necessitates encoding strategies like one-hot encoding that can compromise the categorical relationships and fragment the importance across multiple binary features.</p>
<p><strong>Conclusion:</strong></p>
<p>For modeling zip codes as categorical variables, R‚Äôs <code>rpart</code> clearly wins through its native categorical handling. The key difference is architectural‚ÄîR treats categories as real data types while Python forces everything into numbers first. This gives R a huge advantage in preserving the actual relationships within categorical data.</p>
<p>That said, this doesn‚Äôt make Python useless for machine learning‚Äîfar from it. Python‚Äôs ecosystem has tons of other advantages, and there are ways to work around these categorical limitations with better preprocessing. It really comes down to whether handling categorical variables properly is critical for your specific project.</p>
</section>
</section>
<section id="key-takeaways" class="level2">
<h2 class="anchored" data-anchor-id="key-takeaways">Key Takeaways</h2>
<p>This analysis shows just how critical proper variable encoding is in machine learning. Decision trees are supposed to be interpretable, but that interpretability becomes completely misleading if we don‚Äôt respect what our data actually represents.</p>
<p>The bottom line: <strong>always question whether your categorical variables are properly encoded</strong>. A model that treats zip codes as numbers might run without throwing any errors, but it‚Äôll give you completely wrong insights about what actually drives your predictions.</p>
<p>Our job as data scientists isn‚Äôt just to build models that technically work‚Äîwe need to make sure they‚Äôre telling us the right story about our data.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>